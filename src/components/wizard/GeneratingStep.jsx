import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useBookStore } from '../../store';
import { generateFluxIllustration } from '../../services/segmindService.js';
import { generateStoryPages } from '../../services/openaiService.js';

// Function to check if a string is a Base64 data URL
const isBase64DataUrl = (str) => {
  if (typeof str !== 'string') return false;
  return /^data:image\/(png|jpeg|jpg|webp);base64,/.test(str);
};

// --- NEW: Helper to fetch image URL and convert to Base64 --- 
async function urlToBase64(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
    }
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result); // result includes `data:image/...;base64,...` prefix
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.error("Error converting URL to Base64:", error);
    throw error; // Re-throw the error to be caught by the caller
  }
}
// --- END NEW HELPER ---

// This component simulates the AI generation process
// In a real implementation, it would make API calls to OpenAI for text and images
function GeneratingStep() {
  const { wizardState, addBook, setCurrentBook } = useBookStore();
  const navigate = useNavigate();
  
  // State for overall process phases
  const [overallStatus, setOverallStatus] = useState('generating_story_text'); 
  // Simplified Phases: generating_story_text -> generating_illustrations -> finalizing -> completed | error
  const [errorMessage, setErrorMessage] = useState(null);
  
  // State to hold the story pages generated by OpenAI (text, prompt, charId)
  const [generatedPagesData, setGeneratedPagesData] = useState([]);
  
  // State to hold the final illustration results (Base64 image data or error/skipped)
  // Format: { [pageIndex]: { status: 'succeeded' | 'failed' | 'skipped', imageUrl: string | null, error: string | null } }
  const [illustrationResults, setIllustrationResults] = useState({}); 
  
  // Removed polling interval ref
  // const pollIntervalRef = useRef(null);

  // --- 1. Generate Story Text & Visual Prompts --- 
  useEffect(() => {
    if (overallStatus !== 'generating_story_text') return;
    
    const generateTextAndPrompts = async () => {
      setErrorMessage(null);
      try {
        console.log("Generating story text and visual prompts...");
        const pagesData = await generateStoryPages(wizardState.storyData, 8); 
        console.log("Generated pages data from OpenAI: ", pagesData);
        setGeneratedPagesData(pagesData);
        setOverallStatus('generating_illustrations'); // Move to illustration generation
      } catch (error) {
        console.error("Error generating story text/prompts:", error);
        setErrorMessage(`Failed to generate story: ${error.message}`);
        setOverallStatus('error');
      }
    };
    generateTextAndPrompts();
  }, [overallStatus, wizardState.storyData]); // Include wizardState.storyData

  // --- 2. Generate Illustrations (Replaces Task Creation & Polling) --- 
  useEffect(() => {
    if (overallStatus !== 'generating_illustrations') return;
    if (generatedPagesData.length === 0) {
        console.log("No generated page data found, cannot generate illustrations.");
        setOverallStatus('error');
        setErrorMessage("Failed to generate story content before illustrations.");
        return;
    }

    const generateAllIllustrations = async () => {
        setErrorMessage(null);
        console.log(`Starting illustration generation for ${generatedPagesData.length} pages using Segmind...`);
        
        const results = {};
        let generationErrorOccurred = false;

        // Get characters map for quick lookup
        const charactersMap = wizardState.storyData.bookCharacters.reduce((acc, char) => {
            acc[char.id] = char;
            return acc;
        }, {});

        // Process pages sequentially to avoid overwhelming the browser/API (can be parallelized later if needed)
        for (let i = 0; i < generatedPagesData.length; i++) {
            const page = generatedPagesData[i];
            const character = page.mainCharacterId ? charactersMap[page.mainCharacterId] : null;
            console.log(`Generating illustration for page ${i + 1}...`);
            
            // Update UI status immediately for this page
            setIllustrationResults(prev => ({ ...prev, [i]: { status: 'generating' } }));
            
            if (!page.visualPrompt) {
                console.warn(`Page ${i+1}: Skipping illustration due to missing visual prompt.`);
                results[i] = { status: 'skipped', imageUrl: null, error: 'Missing visual prompt' };
                setIllustrationResults(prev => ({ ...prev, ...results })); // Update state immediately
                continue; 
            }
            
            let referenceImageBase64 = null;
            if (character && character.stylePreview) {
                try {
                    referenceImageBase64 = await urlToBase64(character.stylePreview);
                } catch (conversionError) {
                    console.error(`Page ${i+1}: Failed to load reference image for ${character.name}:`, conversionError);
                    results[i] = { status: 'failed', imageUrl: null, error: `Failed to load reference image: ${conversionError.message}` };
                    generationErrorOccurred = true;
                    setErrorMessage(prev => prev || `Error preparing reference image for page ${i+1}.`);
                    setIllustrationResults(prev => ({ ...prev, ...results })); // Update state immediately
                    continue; 
                }
            } else if (page.mainCharacterId) {
                 console.warn(`Page ${i+1}: Character ${page.mainCharacterId} specified, but no stylePreview available.`);
                 // Allow generation without reference if needed, or mark as skipped/error?
                 // For now, we proceed without reference.
            }

            if (!referenceImageBase64) {
                 console.warn(`Page ${i+1}: Proceeding with illustration generation without a character reference image.`);
            }

            try {
                // --- Call Segmind Service --- 
                const generatedImageBase64 = await generateFluxIllustration(
                    page.visualPrompt,
                    referenceImageBase64, // Pass null or the base64 string
                    { 
                        // Pass any specific options needed for Flux PuLID here
                        // e.g., id_weight: 1.8, start_step: 1, etc.
                    }
                );
                
                console.log(`Page ${i+1}: Successfully generated illustration.`);
                results[i] = { status: 'succeeded', imageUrl: generatedImageBase64, error: null };

            } catch (apiError) {
                console.error(`Page ${i+1}: Error calling Segmind API:`, apiError);
                results[i] = { status: 'failed', imageUrl: null, error: apiError.message || 'Segmind API error' };
                generationErrorOccurred = true;
                setErrorMessage(prev => prev || `Error generating illustration for page ${i+1}.`);
            }
            // Update state after each page generation attempt
            setIllustrationResults(prev => ({ ...prev, ...results }));
        }

        console.log("Finished all illustration generation attempts.");
        // Decide next step based on errors
        if (!generationErrorOccurred) {
            setOverallStatus('finalizing'); // All good, move to finalizing
        } else {
            // Some errors occurred, but we have results for others. 
            // Still move to finalizing, the handleBookCreated function will use placeholders for failed images.
            console.warn("Some illustrations failed to generate. Proceeding to finalize book with placeholders.");
            setOverallStatus('finalizing'); 
            // Optionally set overallStatus to 'error' if *any* failure is critical
            // setOverallStatus('error'); 
        }
    };

    generateAllIllustrations();

  }, [overallStatus, generatedPagesData, wizardState.storyData.bookCharacters]); // Rerun if these change

  // --- 4. Finalize Book Creation (Effect) --- 
  useEffect(() => {
    if (overallStatus !== 'finalizing') return;
    console.log("Finalizing book...");
    handleBookCreated(); 
  }, [overallStatus]);

  // Updated handleBookCreated to use illustrationResults
  const handleBookCreated = () => {
     setErrorMessage(null);
     try {
        const mainCharacter = wizardState.storyData.bookCharacters.find(c => c.role === 'main') || wizardState.storyData.bookCharacters[0];
        const childName = mainCharacter ? mainCharacter.name : 'Child';

        const coverPage = {
          id: 'page-cover',
          type: 'cover',
          text: generateTitle(wizardState.storyData.category, childName),
          imageUrl: mainCharacter?.stylePreview || 'https://via.placeholder.com/600x800?text=Cover',
        };
        const titlePage = {
          id: 'page-title',
          type: 'title',
          text: `${generateTitle(wizardState.storyData.category, childName)}\nA story about ${childName}`,
          imageUrl: '',
        };
        const backCoverPage = {
          id: 'page-back',
          type: 'back-cover',
          text: `The End\n\nCreated with love for ${childName}`,
          imageUrl: '',
        };

        // Combine OpenAI text with Segmind images (from illustrationResults)
        const finalContentPages = generatedPagesData.map((pageData, index) => {
          const result = illustrationResults[index]; // Get result for this page index
          let imageUrl = `https://via.placeholder.com/600x400?text=Page+${index + 1}+(Error)`; // Default placeholder
          
          if (result?.status === 'succeeded' && result.imageUrl) {
            imageUrl = result.imageUrl; // Use the generated Base64 URI
          } else if (result?.status === 'skipped') {
            imageUrl = `https://via.placeholder.com/600x400?text=Page+${index + 1}+(Skipped)`;
          } else if (result?.status === 'failed'){
             console.warn(`Using error placeholder for page ${index+1} due to generation failure.`);
             // imageUrl remains the error placeholder
          } else {
              console.warn(`Using error placeholder for page ${index+1} - unexpected status: ${result?.status}`);
              // imageUrl remains the error placeholder for unknown states
          }
          
          return {
            id: pageData.id || `page-${index + 1}`, 
            type: 'content',
            text: pageData.text,
            visualPrompt: pageData.visualPrompt, 
            mainCharacterId: pageData.mainCharacterId,
            imageUrl: imageUrl, 
          };
        });

        const newBook = {
          id: `book-${Date.now()}`,
          title: generateTitle(wizardState.storyData.category, childName),
          status: 'draft',
          childName,
          artStyleCode: wizardState.storyData.artStyleCode,
          customStyleDescription: wizardState.storyData.customStyleDescription,
          characters: wizardState.storyData.bookCharacters, 
          category: wizardState.storyData.category,
          pages: [coverPage, titlePage, ...finalContentPages, backCoverPage],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };

        addBook(newBook);
        setCurrentBook(newBook);
        setOverallStatus('completed'); 

        setTimeout(() => {
          navigate(`/edit/${newBook.id}`);
        }, 500);
     } catch (error) {
         console.error("Error finalizing book structure:", error);
         setErrorMessage(`Failed to assemble the final book: ${error.message}`);
         setOverallStatus('error');
     }
  };
  
  // Helper to generate a title based on category and child name
  const generateTitle = (category, name) => {
    switch (category) {
      case 'adventure': return `${name}\'s Big Adventure`;
      case 'bedtime': return `${name}\'s Sleepy Time Journey`;
      case 'learning': return `${name} Learns the ABCs`;
      case 'birthday': return `${name}\'s Birthday Surprise`;
      case 'fantasy': return `${name} and the Magic Forest`;
      case 'custom': return `${name}\'s Special Story`;
      default: return `${name}\'s Storybook`;
    }
  };
  
  // Helper to generate first page text
  const generateFirstPageText = (category, name) => {
    switch (category) {
      case 'adventure':
        return `${name} was always looking for adventure. Today was going to be the start of something amazing.`;
      case 'bedtime':
        return `As the stars began to twinkle in the night sky, ${name} snuggled into bed, ready for a magical journey through dreamland.`;
      case 'learning':
        return `${name} loved learning new things. Today, ${name} was excited to explore the wonderful world of letters.`;
      case 'birthday':
        return `It was ${name}'s birthday! The sun seemed to shine extra bright on this special day.`;
      case 'fantasy':
        return `${name} discovered a hidden path behind the old oak tree. It sparkled with tiny lights that danced in the air.`;
      default:
        return `Once upon a time, there was a child named ${name} who was about to begin an amazing journey.`;
    }
  };

  // Determine the display style name
  const getDisplayStyleName = () => {
    if (wizardState.storyData.artStyleCode === 'custom' || wizardState.storyData.customStyleDescription) {
      return wizardState.storyData.customStyleDescription.substring(0, 30) + '...';
    }
    const styleDetails = dzineStyles?.find(s => s.style_code === wizardState.storyData.artStyleCode);
    if (styleDetails?.name) return styleDetails.name;
    
    return (wizardState.storyData.artStyleCode || 'Selected Style').replace('Style-', '').substring(0, 20);
  };

  const calculateProgress = () => {
     const totalPages = generatedPagesData.length;
     const illustrationsAttempted = Object.keys(illustrationResults).length;
     
     // Progress: Text Generation (0-20%), Illustration Generation (20-90%), Finalizing (90-95%), Completed (100%)
     switch (overallStatus) {
         case 'generating_story_text': 
             return 10; // Fixed progress during text gen
         case 'generating_illustrations':
             // Progress based on how many illustrations have been attempted
             const illustrationProgress = totalPages > 0 ? (illustrationsAttempted / totalPages) * 70 : 0; // Scale illustration phase to 70%
             return 20 + Math.floor(illustrationProgress); // Base 20% + illustration progress
         case 'finalizing': 
             return 95;
         case 'completed': 
             return 100;
         case 'error':
             // Show progress up to the point of error if possible
             const baseProgress = 20; // Assume text gen ok
             const errorIllustrationProgress = totalPages > 0 ? (illustrationsAttempted / totalPages) * 70 : 0;
             return Math.min(90, baseProgress + Math.floor(errorIllustrationProgress)); // Cap error progress
         default:
             return 0;
     }
  };

  const getStatusMessage = () => {
    const totalPages = generatedPagesData.length;
    const illustrationsAttempted = Object.keys(illustrationResults).length;
    const successCount = Object.values(illustrationResults).filter(r => r.status === 'succeeded').length;
    const failedCount = Object.values(illustrationResults).filter(r => r.status === 'failed').length;
        
    switch (overallStatus) {
      case 'generating_story_text': return 'Writing your story text & planning illustrations...';
      case 'generating_illustrations': 
          return `Generating page illustrations (${illustrationsAttempted}/${totalPages} attempted)...`;
      case 'finalizing': 
           if (failedCount > 0) {
                return `Finalizing book (${successCount}/${totalPages} illustrations generated)...`;
           } else {
               return 'Finalizing your book...';
           }
      case 'completed': return 'Your book is ready!';
      case 'error': return errorMessage || 'An error occurred during generation.';
      default: return 'Working...';
    }
  };

  const calculatedProgress = calculateProgress(); 

  return (
    <div className="text-center space-y-6 py-8">
      <h2 className="text-2xl font-bold">Creating Your Story</h2>
      
      <div className="max-w-md mx-auto">
        <div className="mb-2 flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculatedProgress}%</span>
        </div>
        <div className="w-full h-4 bg-gray-200 rounded-full overflow-hidden">
          <div 
            className={`h-full transition-all duration-500 ${overallStatus === 'error' ? 'bg-red-500' : 'bg-gradient-to-r from-blue-500 to-purple-600'}`}
            style={{ width: `${calculatedProgress}%` }}
          />
        </div>
      </div>
      
      <div className="my-8 min-h-[40px] flex items-center justify-center">
        {overallStatus !== 'completed' && overallStatus !== 'error' && (
          <svg className="animate-spin h-8 w-8 text-blue-500 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        )}
        {overallStatus === 'error' && (
          <svg className="h-8 w-8 text-red-500 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        )}
         {overallStatus === 'completed' && (
          <svg className="h-8 w-8 text-green-500 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
           </svg>
         )}
        <span className={`text-lg ${overallStatus === 'error' ? 'text-red-600' : 'text-gray-700'}`}>{getStatusMessage()}</span>
      </div>
      
      {overallStatus !== 'error' && (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md mx-auto">
          <p className="text-blue-700">
            We're creating your personalized book with AI. This might take a few minutes...
          </p>
        </div>
      )}
    </div>
  );
}

export default GeneratingStep; 