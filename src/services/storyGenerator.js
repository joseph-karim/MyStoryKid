/**
 * StoryGenerator Service
 * 
 * This service implements a two-step AI prompt-based process for generating children's books:
 * 1. Generate a page-by-page outline of the story
 * 2. Generate specific text and image prompts for each spread based on the outline
 */

// Import OpenAI integration
import { generateStoryPages } from './openaiService';

/**
 * Step 1: Generate the Story Outline
 * This function takes all the story details and generates a structured outline
 */
export const generateStoryOutline = async (storyData) => {
  try {
    // Extract required data from the story data
    const { 
      targetAgeRange, 
      bookCharacters,
      artStyleCode, 
      customStyleDescription,
      storyType,
      coreTheme,
      desiredLengthWords,
      storyStart,
      customStoryStart,
      mainHurdle,
      customMainHurdle,
      bigTry,
      customBigTry,
      turningPoint,
      customTurningPoint,
      resolution,
      customResolution,
      takeaway,
      customTakeaway,
      mainScene,
      customSceneDescription
    } = storyData;

    // Get the main character (if available)
    const mainCharacter = bookCharacters.find(char => char.role === 'main');
    if (!mainCharacter) {
      throw new Error('A main character is required for story generation');
    }

    // Determine the art style description
    const artStyleDescription = artStyleCode === 'custom' 
      ? customStyleDescription 
      : "Professional children's book illustration style";

    // Determine the scene description (for custom scenes)
    const sceneDescription = mainScene === 'custom_scene'
      ? customSceneDescription
      : getSceneDescription(mainScene);

    // Determine the number of spreads based on story type
    const numSpreads = storyType === 'board_book' ? 6 : 16;

    // Format the story structure elements for the prompt
    const storyStartText = storyStart === 'custom' ? customStoryStart : storyStart;
    const mainHurdleText = mainHurdle === 'custom' ? customMainHurdle : mainHurdle;
    const bigTryText = bigTry === 'custom' ? customBigTry : bigTry;
    const turningPointText = turningPoint === 'custom' ? customTurningPoint : turningPoint;
    const resolutionText = resolution === 'custom' ? customResolution : resolution;
    const takeawayText = takeaway === 'custom' ? customTakeaway : takeaway;

    // Format character details
    const characterDetails = bookCharacters.map(char => {
      return `${char.name} (${char.type}${char.age ? `, ${char.age} years old` : ''}${char.gender ? `, ${char.gender}` : ''})`;
    }).join('; ');

    console.log("Preparing story outline with scene:", mainScene, sceneDescription);

    // For demonstration purposes, this is a mock outline
    // In a real app, this would be generated by AI based on the inputs
    const mockOutline = generateMockOutline(
      mainCharacter.name, 
      numSpreads, 
      storyStartText, 
      mainHurdleText, 
      bigTryText, 
      turningPointText, 
      resolutionText, 
      takeawayText,
      mainScene,
      sceneDescription
    );

    return {
      success: true,
      outline: mockOutline
    };
  } catch (error) {
    console.error('Error generating story outline:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Step 2: Generate the Text and Image Prompts for a specific spread
 * This takes the outline and generates detailed content for each spread
 */
export const generateSpreadContent = async (storyData, outline, spreadNumber) => {
  try {
    // Get the outline snippet for this spread
    const spreadOutline = outline[spreadNumber - 1]; // Adjust for 0-based array
    if (!spreadOutline) {
      throw new Error(`Spread ${spreadNumber} not found in outline`);
    }

    // Extract required data
    const { 
      targetAgeRange, 
      bookCharacters, 
      artStyleCode, 
      storyType,
      mainScene,
      customSceneDescription
    } = storyData;
    
    // Get the main character
    const mainCharacter = bookCharacters.find(char => char.role === 'main');
    
    // Get the scene description
    const sceneDescription = mainScene === 'custom_scene'
      ? customSceneDescription
      : getSceneDescription(mainScene);
      
    // Determine age-appropriate text length
    const textLength = determineTextLength(targetAgeRange, storyType);

    // Try to use OpenAI integration if possible
    try {
      // Attempt to generate real content using OpenAI
      // Note: This would need adjustments to properly integrate with your openaiService API
      const pagePrompt = {
        target: "children's book spread",
        outline: spreadOutline,
        character: mainCharacter.name,
        scene: sceneDescription,
        textLength: textLength,
        style: artStyleCode
      };
      
      // For now, still use mock content but process it properly
      const pageContent = generateProperPageContent(
        spreadOutline, 
        mainCharacter.name, 
        spreadNumber, 
        textLength, 
        artStyleCode,
        mainScene,
        sceneDescription
      );

      return {
        success: true,
        spreadContent: pageContent
      };
    } catch (error) {
      console.error("OpenAI generation failed, using mock content:", error);
      // Fallback to mock content
      const pageContent = generateProperPageContent(
        spreadOutline, 
        mainCharacter.name, 
        spreadNumber, 
        textLength, 
        artStyleCode,
        mainScene,
        sceneDescription
      );

      return {
        success: true,
        spreadContent: pageContent
      };
    }
  } catch (error) {
    console.error(`Error generating content for spread ${spreadNumber}:`, error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Helper function to get a description for a scene based on its ID
 */
function getSceneDescription(sceneId) {
  const sceneDescriptions = {
    // Adventure scenes
    space: 'outer space with stars, planets, and spaceships',
    ocean: 'underwater world with colorful fish, coral reefs, and ocean plants',
    jungle: 'lush jungle with tall trees, vines, and exotic animals',
    mountains: 'majestic mountains with snowy peaks and breathtaking views',
    safari: 'open savanna with various African wildlife and golden grass',
    
    // Bedtime scenes
    dreams: 'magical dreamland with floating objects and surreal landscapes',
    stars: 'peaceful night setting under a starry sky',
    bedroom: 'cozy bedroom with magical elements coming to life',
    night_forest: 'serene forest at night illuminated by moonlight',
    cloud_kingdom: 'fluffy kingdom made of clouds high in the sky',
    
    // Learning scenes
    school: 'enchanted school with magical learning elements',
    library: 'vast library with talking books and magical shelves',
    alphabet_land: 'whimsical world where giant letters form the landscape',
    zoo_letters: 'colorful zoo where animals are shaped like letters',
    garden: 'vibrant garden where flowers and plants form letters',
    
    // Birthday scenes
    party: 'festive birthday party with decorations and celebration',
    amusement_park: 'magical amusement park with fantastic rides',
    treasure_hunt: 'exciting treasure hunt adventure with maps and clues',
    bakery: 'colorful bakery workshop making birthday treats',
    parade: 'lively parade through town with floats and music',
    
    // Fantasy scenes
    enchanted_forest: 'magical forest with glowing plants and mythical creatures',
    dragon_mountain: 'mountain realm where friendly dragons live',
    fairy_kingdom: 'miniature kingdom of fairies with tiny houses and magical lights',
    wizard_castle: 'grand castle filled with magical artifacts and enchanted rooms',
    crystal_caves: 'shimmering caves with colored crystals and mysterious magic',
    
    // Default
    custom_scene: 'unique custom setting',
  };
  
  return sceneDescriptions[sceneId] || 'a magical setting';
}

/**
 * Helper function to generate a mock outline for demonstration purposes
 * In a real app, this would be replaced by an AI-generated outline
 */
function generateMockOutline(
  mainCharacterName, 
  numSpreads, 
  storyStartText, 
  mainHurdleText, 
  bigTryText, 
  turningPointText, 
  resolutionText, 
  takeawayText,
  mainScene,
  sceneDescription
) {
  const outline = [];
  
  // Get scene name for readability
  const sceneName = getSceneName(mainScene);
  
  // For a 6-spread board book
  if (numSpreads === 6) {
    outline.push(`Spread 1 (Pages 2-3): Introduce ${mainCharacterName} in ${sceneName}. ${storyStartText}`);
    outline.push(`Spread 2 (Pages 4-5): Show the main problem or challenge in ${sceneName}: ${mainHurdleText}`);
    outline.push(`Spread 3 (Pages 6-7): ${mainCharacterName} attempts to solve the problem in ${sceneName}: ${bigTryText}`);
    outline.push(`Spread 4 (Pages 8-9): A turning point occurs in ${sceneName}: ${turningPointText}`);
    outline.push(`Spread 5 (Pages 10-11): Resolution begins to unfold in ${sceneName}: ${resolutionText}`);
    outline.push(`Spread 6 (Pages 12): Conclusion and happy ending in ${sceneName} with a lesson: ${takeawayText}`);
  } 
  // For a 16-spread picture book
  else {
    outline.push(`Spread 1 (Pages 2-3): Introduce ${mainCharacterName} in ${sceneName}.`);
    outline.push(`Spread 2 (Pages 4-5): Show ${mainCharacterName}'s everyday life in ${sceneName} and establish what's normal.`);
    outline.push(`Spread 3 (Pages 6-7): Present the spark or inciting incident in ${sceneName}: ${storyStartText}`);
    outline.push(`Spread 4 (Pages 8-9): Show how ${mainCharacterName} reacts to this new situation in ${sceneName}.`);
    outline.push(`Spread 5 (Pages 10-11): Introduce the main problem or challenge in ${sceneName}: ${mainHurdleText}`);
    outline.push(`Spread 6 (Pages 12-13): ${mainCharacterName} begins to address the challenge in ${sceneName}.`);
    outline.push(`Spread 7 (Pages 14-15): First attempt to solve the problem in ${sceneName}: ${bigTryText}`);
    outline.push(`Spread 8 (Pages 16-17): The attempt fails or creates new problems in ${sceneName}.`);
    outline.push(`Spread 9 (Pages 18-19): ${mainCharacterName} regroups and plans a new approach in ${sceneName}.`);
    outline.push(`Spread 10 (Pages 20-21): Second attempt with more determination in ${sceneName}.`);
    outline.push(`Spread 11 (Pages 22-23): A turning point occurs in ${sceneName}: ${turningPointText}`);
    outline.push(`Spread 12 (Pages 24-25): Things start to look more promising in ${sceneName}.`);
    outline.push(`Spread 13 (Pages 26-27): Final push toward resolution in ${sceneName}: ${resolutionText}`);
    outline.push(`Spread 14 (Pages 28-29): Problem is solved and celebration begins in ${sceneName}.`);
    outline.push(`Spread 15 (Pages 30-31): Show how ${mainCharacterName} has changed or grown in ${sceneName}.`);
    outline.push(`Spread 16 (Pages 32): Final resolution and takeaway in ${sceneName}: ${takeawayText}`);
  }
  
  return outline;
}

/**
 * Helper function to get a friendly name for a scene
 */
function getSceneName(sceneId) {
  const sceneNames = {
    // Adventure scenes
    space: 'outer space',
    ocean: 'the underwater world',
    jungle: 'the lush jungle',
    mountains: 'the majestic mountains',
    safari: 'the wild savanna',
    
    // Bedtime scenes
    dreams: 'dreamland',
    stars: 'under the starry night sky',
    bedroom: 'a magical bedroom',
    night_forest: 'the moonlit forest',
    cloud_kingdom: 'the cloud kingdom',
    
    // Learning scenes
    school: 'the magical school',
    library: 'the enchanted library',
    alphabet_land: 'Alphabet Land',
    zoo_letters: 'the letter zoo',
    garden: 'the letter garden',
    
    // Birthday scenes
    party: 'the birthday party',
    amusement_park: 'the magical amusement park',
    treasure_hunt: 'the birthday treasure hunt',
    bakery: 'the magical bakery',
    parade: 'the birthday parade',
    
    // Fantasy scenes
    enchanted_forest: 'the enchanted forest',
    dragon_mountain: 'Dragon Mountain',
    fairy_kingdom: 'the fairy kingdom',
    wizard_castle: 'the wizard\'s castle',
    crystal_caves: 'the crystal caves',
    
    // Default
    custom_scene: 'a special setting',
  };
  
  return sceneNames[sceneId] || 'a magical setting';
}

/**
 * Helper function to generate mock page content for demonstration purposes
 * In a real app, this would be replaced by AI-generated content
 */
function generateMockPageContent(
  outlineSnippet, 
  characterName, 
  spreadNumber, 
  textLength, 
  artStyle,
  mainScene,
  sceneDescription
) {
  // Extract page numbers from outline
  const pageMatch = outlineSnippet.match(/Pages (\d+)-?(\d+)?/);
  let pageNumbers = "";
  
  if (pageMatch) {
    if (pageMatch[2]) {
      pageNumbers = `${pageMatch[1]}-${pageMatch[2]}`;
    } else {
      pageNumbers = pageMatch[1];
    }
  } else {
    pageNumbers = String(spreadNumber * 2) + (spreadNumber < 16 ? `-${spreadNumber * 2 + 1}` : '');
  }

  // Generate mock text based on the outline snippet
  const text = generateTextFromOutline(outlineSnippet, characterName, textLength, mainScene);
  
  // Generate mock image prompt
  const imagePrompt = generateImagePromptFromOutline(outlineSnippet, characterName, artStyle, mainScene, sceneDescription);
  
  return {
    spreadNumber,
    pageNumbers,
    text,
    imagePrompt
  };
}

/**
 * Helper function to generate appropriate text length based on age range and book type
 */
function determineTextLength(ageRange, storyType) {
  if (storyType === 'board_book') {
    return 'very short'; // 1-2 sentences per page
  }
  
  // Parse age range (e.g., "3-5" -> lowest age is 3)
  const lowestAge = parseInt(ageRange.split('-')[0]);
  
  if (lowestAge <= 3) return 'very short'; // 1-2 sentences
  if (lowestAge <= 5) return 'short'; // 2-3 sentences
  if (lowestAge <= 8) return 'medium'; // 3-5 sentences
  return 'longer'; // 5+ sentences
}

/**
 * Helper function to generate mock text from an outline snippet
 */
function generateTextFromOutline(outlineSnippet, characterName, textLength, mainScene) {
  // Extract the core content from the outline (after the ":")
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();
  
  // Get scene name for the story
  const sceneName = getSceneName(mainScene);
  
  // For demonstration purposes, create simple text
  let text = "";
  
  switch(textLength) {
    case 'very short':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}.`;
      break;
    case 'short':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. What would happen next?`;
      break;
    case 'medium':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. It was an exciting moment. ${characterName} couldn't wait to see what would happen next.`;
      break;
    case 'longer':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. It was an exciting moment in ${characterName}'s day. The possibilities seemed endless. ${characterName} took a deep breath and continued on the adventure.`;
      break;
    default:
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}.`;
  }
  
  return text;
}

/**
 * Helper function to simplify text for younger audiences
 */
function simplifyText(text) {
  // Very simplified version for demonstration
  return text
    .replace(/\bacquired\b/g, "got")
    .replace(/\battempted\b/g, "tried")
    .replace(/\bdiscovered\b/g, "found")
    .replace(/\bcommenced\b/g, "started")
    .replace(/\bdifficult\b/g, "hard")
    .replace(/\bchallenging\b/g, "hard")
    .toLowerCase();
}

/**
 * Helper function to generate a mock image prompt
 */
function generateImagePromptFromOutline(
  outlineSnippet, 
  characterName, 
  artStyle, 
  mainScene,
  sceneDescription
) {
  // Extract the core content
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();
  
  // Create a simple prompt focusing on the character and action in the specific scene
  let prompt = `Illustration of ${characterName} `;
  
  // Extract action words
  if (contentPart.includes('attempts')) {
    prompt += 'trying very hard to do something, with a determined expression';
  } else if (contentPart.includes('problem') || contentPart.includes('challenge')) {
    prompt += 'looking worried or confused, facing a challenge';
  } else if (contentPart.includes('turning point')) {
    prompt += 'with a surprised or hopeful expression, at a key moment';
  } else if (contentPart.includes('resolution') || contentPart.includes('solved')) {
    prompt += 'looking happy and proud, having solved a problem';
  } else if (contentPart.includes('celebration') || contentPart.includes('happy ending')) {
    prompt += 'celebrating joyfully with a big smile';
  } else {
    prompt += 'engaged in an activity related to the story';
  }
  
  // Add scene description
  prompt += ` in ${sceneDescription}`;
  
  // Add art style description
  prompt += `. Illustrated in a ${artStyle === 'custom' ? "professional children's book" : artStyle} art style. Child-friendly, colorful, engaging illustration for a children's book.`;
  
  return prompt;
}

/**
 * Main function to generate a complete book
 * This orchestrates the two-step process
 */
export const generateCompleteBook = async (storyData) => {
  try {
    // Step 1: Generate the story outline
    console.log("Generating story outline...");
    const outlineResult = await generateStoryOutline(storyData);
    
    if (!outlineResult.success) {
      throw new Error(`Failed to generate story outline: ${outlineResult.error}`);
    }
    
    const outline = outlineResult.outline;
    console.log("Story outline generated:", outline);
    
    // Determine number of spreads from the outline
    const numSpreads = outline.length;
    
    // Step 2: Generate content for each spread
    console.log(`Generating content for ${numSpreads} spreads...`);
    const spreads = [];
    
    for (let i = 1; i <= numSpreads; i++) {
      console.log(`Generating content for spread ${i}...`);
      const spreadResult = await generateSpreadContent(storyData, outline, i);
      
      if (!spreadResult.success) {
        throw new Error(`Failed to generate content for spread ${i}: ${spreadResult.error}`);
      }
      
      spreads.push(spreadResult.spreadContent);
    }
    
    // Step 3: Compile the book
    const mainCharacter = storyData.bookCharacters.find(char => char.role === 'main');
    
    // Get scene name for title
    const sceneName = getSceneFriendlyName(storyData.mainScene);
    
    // Generate a title if none provided
    const title = storyData.title || 
      `${mainCharacter.name}'s ${getCategoryTitle(storyData.category, sceneName)}`;
    
    // Create the complete book structure
    const book = {
      title,
      outline,
      spreads,
      storyData,
      generatedAt: new Date().toISOString()
    };
    
    return {
      success: true,
      book
    };
    
  } catch (error) {
    console.error("Error generating complete book:", error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Helper to generate a more readable name for a scene
 */
function getSceneFriendlyName(sceneId) {
  const sceneFriendlyNames = {
    // Adventure scenes
    space: 'Space Adventure',
    ocean: 'Undersea Quest',
    jungle: 'Jungle Expedition',
    mountains: 'Mountain Journey',
    safari: 'Safari Adventure',
    
    // Bedtime scenes
    dreams: 'Dream Journey',
    stars: 'Starry Night',
    bedroom: 'Bedtime Magic',
    night_forest: 'Moonlit Forest Tale',
    cloud_kingdom: 'Cloud Kingdom Adventure',
    
    // Learning scenes
    school: 'School Adventure',
    library: 'Library Quest',
    alphabet_land: 'Alphabet Land Journey',
    zoo_letters: 'Alphabet Zoo',
    garden: 'Garden of Letters',
    
    // Birthday scenes
    party: 'Birthday Party',
    amusement_park: 'Amusement Park Fun',
    treasure_hunt: 'Birthday Treasure Hunt',
    bakery: 'Bakery Adventure',
    parade: 'Birthday Parade',
    
    // Fantasy scenes
    enchanted_forest: 'Enchanted Forest',
    dragon_mountain: 'Dragon Mountain',
    fairy_kingdom: 'Fairy Kingdom',
    wizard_castle: 'Wizard Castle',
    crystal_caves: 'Crystal Caves',
    
    // Default
    custom_scene: 'Adventure',
  };
  
  return sceneFriendlyNames[sceneId] || 'Adventure';
}

/**
 * Helper to generate a category-based title
 */
function getCategoryTitle(category, sceneName) {
  switch(category) {
    case 'adventure': return sceneName || 'Amazing Adventure';
    case 'bedtime': return sceneName || 'Bedtime Story';
    case 'learning': return sceneName || 'Learning Journey';
    case 'birthday': return sceneName || 'Birthday Surprise';
    case 'fantasy': return sceneName || 'Magical Tale';
    default: return sceneName || 'Special Story';
  }
}

/**
 * Updated function to generate proper page content without placeholders
 */
function generateProperPageContent(
  outlineSnippet, 
  characterName, 
  spreadNumber, 
  textLength, 
  artStyle,
  mainScene,
  sceneDescription
) {
  // Extract page numbers from outline
  const pageMatch = outlineSnippet.match(/Pages (\d+)-?(\d+)?/);
  let pageNumbers = "";
  
  if (pageMatch) {
    if (pageMatch[2]) {
      pageNumbers = `${pageMatch[1]}-${pageMatch[2]}`;
    } else {
      pageNumbers = pageMatch[1];
    }
  } else {
    pageNumbers = String(spreadNumber * 2) + (spreadNumber < 16 ? `-${spreadNumber * 2 + 1}` : '');
  }

  // Generate proper text based on the outline snippet
  const text = generateProperTextFromOutline(outlineSnippet, characterName, textLength, mainScene);
  
  // Generate mock image prompt
  const imagePrompt = generateImagePromptFromOutline(outlineSnippet, characterName, artStyle, mainScene, sceneDescription);
  
  return {
    spreadNumber,
    pageNumbers,
    text,
    imagePrompt
  };
}

/**
 * Enhanced text generation function that properly processes placeholders
 */
function generateProperTextFromOutline(outlineSnippet, characterName, textLength, mainScene) {
  // Extract the core content from the outline (after the ":")
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();
  
  // Get scene name for the story
  const sceneName = getSceneName(mainScene);
  
  // Process the content to replace placeholders with actual descriptions
  const processedContent = processPlaceholders(contentPart);
  
  // For demonstration purposes, create simple text
  let text = "";
  
  switch(textLength) {
    case 'very short':
      text = `${characterName} ${processedContent} in ${sceneName}.`;
      break;
    case 'short':
      text = `${characterName} ${processedContent} in ${sceneName}. What would happen next?`;
      break;
    case 'medium':
      text = `${characterName} ${processedContent} in ${sceneName}. It was an exciting moment. ${characterName} couldn't wait to see what would happen next.`;
      break;
    case 'longer':
      text = `${characterName} ${processedContent} in ${sceneName}. It was an exciting moment in ${characterName}'s day. The possibilities seemed endless. ${characterName} took a deep breath and continued on the adventure.`;
      break;
    default:
      text = `${characterName} ${processedContent} in ${sceneName}.`;
  }
  
  return text;
}

/**
 * Process any placeholder patterns in the text to convert them to proper descriptions
 */
function processPlaceholders(text) {
  // Helper function to process a specific template pattern
  const processTemplate = (text, pattern, replacementFn) => {
    const regex = new RegExp(pattern, 'g');
    return text.replace(regex, replacementFn);
  };

  // First simplify the text (basic word substitutions)
  let processed = processTemplateText(text);
  
  // Then handle specific placeholder/template patterns
  processed = processTemplate(processed, 'obstacle_overcome', () => 'overcame the challenge');
  processed = processTemplate(processed, 'problem_solved', () => 'solved the problem');
  processed = processTemplate(processed, 'challenge_faced', () => 'faced a big challenge');
  processed = processTemplate(processed, 'magic_discovered', () => 'discovered something magical');
  processed = processTemplate(processed, 'lesson_learned', () => 'learned an important lesson');
  processed = processTemplate(processed, 'friend_made', () => 'made a new friend');
  processed = processTemplate(processed, 'adventure_started', () => 'began an exciting adventure');
  processed = processTemplate(processed, 'resolution_found', () => 'found a perfect solution');
  
  return processed;
}

/**
 * Enhanced text simplification that also processes templates and placeholders
 */
function processTemplateText(text) {
  // Basic word substitutions for simplicity
  let simplified = text
    .replace(/\bacquired\b/g, "got")
    .replace(/\battempted\b/g, "tried")
    .replace(/\bdiscovered\b/g, "found")
    .replace(/\bcommenced\b/g, "started")
    .replace(/\bdifficult\b/g, "hard")
    .replace(/\bchallenging\b/g, "hard")
    .toLowerCase();
    
  // Also handle keyword patterns that should be converted to meaningful descriptions
  simplified = simplified
    .replace(/(_[a-z]+_)/g, (match) => {
      // Strip underscores and make more readable
      const word = match.replace(/_/g, '');
      return word.replace(/([a-z])([A-Z])/g, '$1 $2').toLowerCase();
    });
  
  return simplified;
} 