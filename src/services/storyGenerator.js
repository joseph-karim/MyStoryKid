/**
 * StoryGenerator Service
 *
 * This service implements a two-step AI prompt-based process for generating children's books:
 * 1. Generate a page-by-page outline of the story
 * 2. Generate specific text and image prompts for each spread based on the outline
 */

// Import OpenAI integration
import { generateOutlineFromPrompt, generateSpreadContentFromPrompt } from './openaiService';
import { v4 as uuidv4 } from 'uuid';
import * as openaiImageService from './openaiImageService';
import { uploadImageAndGetUrl } from './imageUploadService';

/**
 * Step 1: Generate the Story Outline
 * This function takes all the story details and generates a structured outline
 */
export const generateStoryOutline = async (storyData) => {
  try {
    // Extract required data from the story data
    const {
      targetAgeRange,
      bookCharacters,
      artStyleCode,
      customStyleDescription,
      storyType,
      coreTheme,
      desiredLengthWords,
      storyStart,
      customStoryStart,
      mainHurdle,
      customMainHurdle,
      bigTry,
      customBigTry,
      turningPoint,
      customTurningPoint,
      resolution,
      customResolution,
      takeaway,
      customTakeaway,
      mainScene,
      customSceneDescription
    } = storyData;

    // Get the main character (if available)
    const mainCharacter = bookCharacters.find(char => char.role === 'main');
    if (!mainCharacter) {
      throw new Error('A main character is required for story generation');
    }

    // Determine the art style description
    const artStyleDescription = artStyleCode === 'custom'
      ? customStyleDescription
      : "Professional children's book illustration style";

    // Determine the scene description (for custom scenes)
    const sceneDescription = mainScene === 'custom_scene'
      ? customSceneDescription
      : getSceneDescription(mainScene);

    // Determine the number of spreads based on story type
    const numSpreads = storyType === 'board_book' ? 6 : 16;

    // Format the story structure elements for the prompt
    const storyStartText = storyStart === 'custom' ? customStoryStart : storyStart;
    const mainHurdleText = mainHurdle === 'custom' ? customMainHurdle : mainHurdle;
    const bigTryText = bigTry === 'custom' ? customBigTry : bigTry;
    const turningPointText = turningPoint === 'custom' ? customTurningPoint : turningPoint;
    const resolutionText = resolution === 'custom' ? customResolution : resolution;
    const takeawayText = takeaway === 'custom' ? customTakeaway : takeaway;

    // Format character details
    const characterDetails = bookCharacters.map(char => {
      return `${char.name} (${char.type}${char.age ? `, ${char.age} years old` : ''}${char.gender ? `, ${char.gender}` : ''})`;
    }).join('; ');

    console.log("Preparing story outline with scene:", mainScene, sceneDescription);

    // For demonstration purposes, this is a mock outline
    // In a real app, this would be generated by AI based on the inputs
    const mockOutline = generateMockOutline(
      mainCharacter.name,
      numSpreads,
      storyStartText,
      mainHurdleText,
      bigTryText,
      turningPointText,
      resolutionText,
      takeawayText,
      mainScene,
      sceneDescription
    );

    return {
      success: true,
      outline: mockOutline
    };
  } catch (error) {
    console.error('Error generating story outline:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Step 2: Generate the Text and Image Prompts for a specific spread
 * This takes the outline and generates detailed content for each spread
 */
export const generateSpreadContent = async (storyData, outline, spreadNumber) => {
  try {
    // Get the outline snippet for this spread
    const spreadOutline = outline[spreadNumber - 1]; // Adjust for 0-based array
    if (!spreadOutline) {
      throw new Error(`Spread ${spreadNumber} not found in outline`);
    }

    // Extract required data
    const {
      targetAgeRange,
      bookCharacters,
      artStyleCode,
      storyType,
      mainScene,
      customSceneDescription
    } = storyData;

    // Get the main character
    const mainCharacter = bookCharacters.find(char => char.role === 'main');

    // Get the scene description
    const sceneDescription = mainScene === 'custom_scene'
      ? customSceneDescription
      : getSceneDescription(mainScene);

    // Determine age-appropriate text length
    const textLength = determineTextLength(targetAgeRange, storyType);

    // Try to use OpenAI integration if possible
    try {
      // Attempt to generate real content using OpenAI
      // Note: This would need adjustments to properly integrate with your openaiService API
      const pagePrompt = {
        target: "children's book spread",
        outline: spreadOutline,
        character: mainCharacter.name,
        scene: sceneDescription,
        textLength: textLength,
        style: artStyleCode
      };

      // For now, still use mock content but process it properly
      const pageContent = generateProperPageContent(
        spreadOutline,
        mainCharacter.name,
        spreadNumber,
        textLength,
        artStyleCode,
        mainScene,
        sceneDescription
      );

      return {
        success: true,
        spreadContent: pageContent
      };
    } catch (error) {
      console.error("OpenAI generation failed, using mock content:", error);
      // Fallback to mock content
      const pageContent = generateProperPageContent(
        spreadOutline,
        mainCharacter.name,
        spreadNumber,
        textLength,
        artStyleCode,
        mainScene,
        sceneDescription
      );

      return {
        success: true,
        spreadContent: pageContent
      };
    }
  } catch (error) {
    console.error(`Error generating content for spread ${spreadNumber}:`, error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Helper function to get a description for a scene based on its ID
 */
function getSceneDescription(sceneId) {
  const sceneDescriptions = {
    // Adventure scenes
    space: 'outer space with stars, planets, and spaceships',
    ocean: 'underwater world with colorful fish, coral reefs, and ocean plants',
    jungle: 'lush jungle with tall trees, vines, and exotic animals',
    mountains: 'majestic mountains with snowy peaks and breathtaking views',
    safari: 'open savanna with various African wildlife and golden grass',

    // Bedtime scenes
    dreams: 'magical dreamland with floating objects and surreal landscapes',
    stars: 'peaceful night setting under a starry sky',
    bedroom: 'cozy bedroom with magical elements coming to life',
    night_forest: 'serene forest at night illuminated by moonlight',
    cloud_kingdom: 'fluffy kingdom made of clouds high in the sky',

    // Learning scenes
    school: 'enchanted school with magical learning elements',
    library: 'vast library with talking books and magical shelves',
    alphabet_land: 'whimsical world where giant letters form the landscape',
    zoo_letters: 'colorful zoo where animals are shaped like letters',
    garden: 'vibrant garden where flowers and plants form letters',

    // Birthday scenes
    party: 'festive birthday party with decorations and celebration',
    amusement_park: 'magical amusement park with fantastic rides',
    treasure_hunt: 'exciting treasure hunt adventure with maps and clues',
    bakery: 'colorful bakery workshop making birthday treats',
    parade: 'lively parade through town with floats and music',

    // Fantasy scenes
    enchanted_forest: 'magical forest with glowing plants and mythical creatures',
    dragon_mountain: 'mountain realm where friendly dragons live',
    fairy_kingdom: 'miniature kingdom of fairies with tiny houses and magical lights',
    wizard_castle: 'grand castle filled with magical artifacts and enchanted rooms',
    crystal_caves: 'shimmering caves with colored crystals and mysterious magic',

    // Default
    custom_scene: 'unique custom setting',
  };

  return sceneDescriptions[sceneId] || 'a magical setting';
}

/**
 * Helper function to generate a mock outline for demonstration purposes
 * In a real app, this would be replaced by an AI-generated outline
 */
function generateMockOutline(
  mainCharacterName,
  numSpreads,
  storyStartText,
  mainHurdleText,
  bigTryText,
  turningPointText,
  resolutionText,
  takeawayText,
  mainScene,
  sceneDescription
) {
  const outline = [];

  // Get scene name for readability
  const sceneName = getSceneName(mainScene);

  // For a 6-spread board book
  if (numSpreads === 6) {
    outline.push(`Spread 1 (Pages 2-3): Introduce ${mainCharacterName} in ${sceneName}. ${storyStartText}`);
    outline.push(`Spread 2 (Pages 4-5): Show the main problem or challenge in ${sceneName}: ${mainHurdleText}`);
    outline.push(`Spread 3 (Pages 6-7): ${mainCharacterName} attempts to solve the problem in ${sceneName}: ${bigTryText}`);
    outline.push(`Spread 4 (Pages 8-9): A turning point occurs in ${sceneName}: ${turningPointText}`);
    outline.push(`Spread 5 (Pages 10-11): Resolution begins to unfold in ${sceneName}: ${resolutionText}`);
    outline.push(`Spread 6 (Pages 12): Conclusion and happy ending in ${sceneName} with a lesson: ${takeawayText}`);
  }
  // For a 16-spread picture book
  else {
    outline.push(`Spread 1 (Pages 2-3): Introduce ${mainCharacterName} in ${sceneName}.`);
    outline.push(`Spread 2 (Pages 4-5): Show ${mainCharacterName}'s everyday life in ${sceneName} and establish what's normal.`);
    outline.push(`Spread 3 (Pages 6-7): Present the spark or inciting incident in ${sceneName}: ${storyStartText}`);
    outline.push(`Spread 4 (Pages 8-9): Show how ${mainCharacterName} reacts to this new situation in ${sceneName}.`);
    outline.push(`Spread 5 (Pages 10-11): Introduce the main problem or challenge in ${sceneName}: ${mainHurdleText}`);
    outline.push(`Spread 6 (Pages 12-13): ${mainCharacterName} begins to address the challenge in ${sceneName}.`);
    outline.push(`Spread 7 (Pages 14-15): First attempt to solve the problem in ${sceneName}: ${bigTryText}`);
    outline.push(`Spread 8 (Pages 16-17): The attempt fails or creates new problems in ${sceneName}.`);
    outline.push(`Spread 9 (Pages 18-19): ${mainCharacterName} regroups and plans a new approach in ${sceneName}.`);
    outline.push(`Spread 10 (Pages 20-21): Second attempt with more determination in ${sceneName}.`);
    outline.push(`Spread 11 (Pages 22-23): A turning point occurs in ${sceneName}: ${turningPointText}`);
    outline.push(`Spread 12 (Pages 24-25): Things start to look more promising in ${sceneName}.`);
    outline.push(`Spread 13 (Pages 26-27): Final push toward resolution in ${sceneName}: ${resolutionText}`);
    outline.push(`Spread 14 (Pages 28-29): Problem is solved and celebration begins in ${sceneName}.`);
    outline.push(`Spread 15 (Pages 30-31): Show how ${mainCharacterName} has changed or grown in ${sceneName}.`);
    outline.push(`Spread 16 (Pages 32): Final resolution and takeaway in ${sceneName}: ${takeawayText}`);
  }

  return outline;
}

/**
 * Helper function to get a friendly name for a scene
 */
function getSceneName(sceneId) {
  const sceneNames = {
    // Adventure scenes
    space: 'outer space',
    ocean: 'the underwater world',
    jungle: 'the lush jungle',
    mountains: 'the majestic mountains',
    safari: 'the wild savanna',

    // Bedtime scenes
    dreams: 'dreamland',
    stars: 'under the starry night sky',
    bedroom: 'a magical bedroom',
    night_forest: 'the moonlit forest',
    cloud_kingdom: 'the cloud kingdom',

    // Learning scenes
    school: 'the magical school',
    library: 'the enchanted library',
    alphabet_land: 'Alphabet Land',
    zoo_letters: 'the letter zoo',
    garden: 'the letter garden',

    // Birthday scenes
    party: 'the birthday party',
    amusement_park: 'the magical amusement park',
    treasure_hunt: 'the birthday treasure hunt',
    bakery: 'the magical bakery',
    parade: 'the birthday parade',

    // Fantasy scenes
    enchanted_forest: 'the enchanted forest',
    dragon_mountain: 'Dragon Mountain',
    fairy_kingdom: 'the fairy kingdom',
    wizard_castle: 'the wizard\'s castle',
    crystal_caves: 'the crystal caves',

    // Default
    custom_scene: 'a special setting',
  };

  return sceneNames[sceneId] || 'a magical setting';
}

/**
 * Helper function to generate mock page content for demonstration purposes
 * In a real app, this would be replaced by AI-generated content
 */
function generateMockPageContent(
  outlineSnippet,
  characterName,
  spreadNumber,
  textLength,
  artStyle,
  mainScene,
  sceneDescription
) {
  // Extract page numbers from outline
  const pageMatch = outlineSnippet.match(/Pages (\d+)-?(\d+)?/);
  let pageNumbers = "";

  if (pageMatch) {
    if (pageMatch[2]) {
      pageNumbers = `${pageMatch[1]}-${pageMatch[2]}`;
    } else {
      pageNumbers = pageMatch[1];
    }
  } else {
    pageNumbers = String(spreadNumber * 2) + (spreadNumber < 16 ? `-${spreadNumber * 2 + 1}` : '');
  }

  // Generate mock text based on the outline snippet
  const text = generateTextFromOutline(outlineSnippet, characterName, textLength, mainScene);

  // Generate mock image prompt
  const imagePrompt = generateImagePromptFromOutline(outlineSnippet, characterName, artStyle, mainScene, sceneDescription);

  return {
    spreadNumber,
    pageNumbers,
    text,
    imagePrompt
  };
}

/**
 * Helper function to generate appropriate text length based on age range and book type
 * This function is critical for ensuring age-appropriate content
 */
function determineTextLength(ageRange, storyType) {
  console.log(`Determining text length for age range: ${ageRange}, book type: ${storyType}`);

  // Board books always get very short text regardless of age range
  if (storyType === 'board_book') {
    console.log('Board book detected - using very short text (1-2 simple sentences)');
    return 'very short'; // 1-2 very simple sentences per page
  }

  // Parse age range (e.g., "3-5" -> lowest age is 3)
  // If parsing fails, default to age 4
  const ageParts = ageRange.split('-');
  const lowestAge = parseInt(ageParts[0]) || 4;
  console.log(`Parsed lowest age as: ${lowestAge}`);

  // Rhyming books tend to be shorter
  if (storyType === 'rhyming') {
    if (lowestAge <= 3) {
      console.log('Rhyming book for very young children - using very short text');
      return 'very short';
    } else {
      console.log('Rhyming book - using short text');
      return 'short';
    }
  }

  // Early readers need controlled vocabulary but can have more text
  if (storyType === 'early_reader') {
    console.log('Early reader book - using medium text with simple vocabulary');
    return 'medium';
  }

  // Standard picture books vary by age
  if (lowestAge <= 3) {
    console.log('Very young audience (0-3) - using very short text (1-2 simple sentences)');
    return 'very short'; // 1-2 very simple sentences
  }
  if (lowestAge <= 5) {
    console.log('Young audience (3-5) - using short text (2-3 simple sentences)');
    return 'short'; // 2-3 simple sentences
  }
  if (lowestAge <= 8) {
    console.log('Middle audience (6-8) - using medium text (3-5 sentences with some complexity)');
    return 'medium'; // 3-5 sentences with some complexity
  }

  console.log('Older audience (9+) - using longer text (5+ sentences with more complexity)');
  return 'longer'; // 5+ sentences with more complexity
}

/**
 * Helper function to generate mock text from an outline snippet
 */
function generateTextFromOutline(outlineSnippet, characterName, textLength, mainScene) {
  // Extract the core content from the outline (after the ":")
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();

  // Get scene name for the story
  const sceneName = getSceneName(mainScene);

  // For demonstration purposes, create simple text
  let text = "";

  switch(textLength) {
    case 'very short':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}.`;
      break;
    case 'short':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. What would happen next?`;
      break;
    case 'medium':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. It was an exciting moment. ${characterName} couldn't wait to see what would happen next.`;
      break;
    case 'longer':
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}. It was an exciting moment in ${characterName}'s day. The possibilities seemed endless. ${characterName} took a deep breath and continued on the adventure.`;
      break;
    default:
      text = `${characterName} ${simplifyText(contentPart)} in ${sceneName}.`;
  }

  return text;
}

/**
 * Helper function to simplify text for younger audiences
 */
function simplifyText(text) {
  // Very simplified version for demonstration
  return text
    .replace(/\bacquired\b/g, "got")
    .replace(/\battempted\b/g, "tried")
    .replace(/\bdiscovered\b/g, "found")
    .replace(/\bcommenced\b/g, "started")
    .replace(/\bdifficult\b/g, "hard")
    .replace(/\bchallenging\b/g, "hard")
    .toLowerCase();
}

/**
 * Helper function to generate a mock image prompt
 */
function generateImagePromptFromOutline(
  outlineSnippet,
  characterName,
  artStyle,
  mainScene,
  sceneDescription
) {
  // Extract the core content
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();

  // Create a simple prompt focusing on the character and action in the specific scene
  let prompt = `Illustration of ${characterName} `;

  // Extract action words
  if (contentPart.includes('attempts')) {
    prompt += 'trying very hard to do something, with a determined expression';
  } else if (contentPart.includes('problem') || contentPart.includes('challenge')) {
    prompt += 'looking worried or confused, facing a challenge';
  } else if (contentPart.includes('turning point')) {
    prompt += 'with a surprised or hopeful expression, at a key moment';
  } else if (contentPart.includes('resolution') || contentPart.includes('solved')) {
    prompt += 'looking happy and proud, having solved a problem';
  } else if (contentPart.includes('celebration') || contentPart.includes('happy ending')) {
    prompt += 'celebrating joyfully with a big smile';
  } else {
    prompt += 'engaged in an activity related to the story';
  }

  // Add scene description
  prompt += ` in ${sceneDescription}`;

  // Add art style description
  prompt += `. Illustrated in a ${artStyle === 'custom' ? "professional children's book" : artStyle} art style. Child-friendly, colorful, engaging illustration for a children's book.`;

  return prompt;
}

/**
 * Main function to generate a complete book
 * This orchestrates the two-step process
 */
export const generateCompleteBook = async (storyData) => {
  console.log("[generateCompleteBook] Starting generation with data:", storyData);
  try {
    // --- Validate Input Data ---
    const errors = [];
    if (!storyData.category) errors.push('Story category is required');
    if (!storyData.mainScene) errors.push('Main scene/setting is required');
    if (!storyData.artStyleCode) errors.push('Art style is required');
    if (!storyData.bookCharacters || storyData.bookCharacters.length === 0) errors.push('At least one character is required');
    else if (!storyData.bookCharacters.find(char => char.role === 'main')) errors.push('A main character is required');
    // Add validation for story structure elements?
    if (!storyData.storyStart) errors.push('Story Start is required');
    if (!storyData.mainHurdle) errors.push('Main Hurdle is required');
    if (!storyData.bigTry) errors.push('Big Try is required');
    if (!storyData.turningPoint) errors.push('Turning Point is required');
    if (!storyData.resolution) errors.push('Resolution is required');
    if (!storyData.takeaway) errors.push('Takeaway is required');


    if (errors.length > 0) {
      console.error("[generateCompleteBook] Validation failed:", errors);
      return { success: false, error: errors.join('. ') };
    }

    const mainCharacter = storyData.bookCharacters.find(char => char.role === 'main');
    const numSpreads = storyData.storyType === 'board_book' ? 6 : (storyData.desiredLengthWords <= 400 ? 12 : 16); // Adjust based on length/type
    const sceneDesc = storyData.mainScene === 'custom_scene' ? storyData.customSceneDescription : getSceneDescription(storyData.mainScene);
    const artStyleDesc = storyData.artStyleCode === 'custom' ? storyData.customStyleDescription : `using the style identifier '${storyData.artStyleCode}'`; // Or lookup friendly name?

    // --- STEP 1: Generate Outline ---
    console.log("[generateCompleteBook] Formatting Step 1 prompt (Outline)...");
    const outlinePrompt = `
      **Goal:** Generate a concise spread-by-spread outline for a children's book.

      **Core Book Details:**
      * Target Reading Age Range: ${storyData.ageRange || '3-8'} years old
      * Target Illustration Age Range: ${storyData.ageRange || '3-8'} years old
      * Main Character(s): ${storyData.bookCharacters.map(c => `${c.name} (${c.type}, ${c.age}, ${c.gender}, Traits: ${c.traits?.join(', ') || 'N/A'})`).join('; ')}
      * Supporting Characters (Optional): ${storyData.bookCharacters.filter(c => c.role !== 'main').map(c => c.name).join(', ') || 'None'}
      * Art Style: ${artStyleDesc}
      * Core Theme: ${storyData.coreTheme || 'Not specified'}
      * Overall Length: ${numSpreads} Spreads (${numSpreads * 2} pages, excluding cover/title)
      * Story Spark: ${storyData.storyStart === 'custom' ? storyData.customStoryStart : storyData.storyStart}
      * Main Hurdle: ${storyData.mainHurdle === 'custom' ? storyData.customMainHurdle : storyData.mainHurdle}
      * Character's Big Try: ${storyData.bigTry === 'custom' ? storyData.customBigTry : storyData.bigTry}
      * Key Turning Point: ${storyData.turningPoint === 'custom' ? storyData.customTurningPoint : storyData.turningPoint}
      * Happy Ending: ${storyData.resolution === 'custom' ? storyData.customResolution : storyData.resolution}
      * Takeaway: ${storyData.takeaway === 'custom' ? storyData.customTakeaway : storyData.takeaway}
      * Setting: ${sceneDesc}
      ${storyData.specificRequests ? `* Specific Requests: ${storyData.specificRequests}` : ''}

      **Instructions for AI:**
      1. Based on all the core book details, create a brief outline distributing the story events across the specified ${numSpreads} spreads. Define a "spread" as two facing pages (e.g., Spread 1 = Pages 2-3).
      2. For each spread (from 1 to ${numSpreads}), write 1-2 sentences describing the main action/event and how it connects to the plot points.
      3. Ensure logical progression according to the Story Details. Keep descriptions concise.

      **Output Format:** Provide the output as a JSON array of strings, where each string is the outline for one spread. Example for 2 spreads: ["Spread 1: Description...", "Spread 2: Description..."]
    `;

    // Assuming generateOutlineFromPrompt takes the prompt and returns { success: true, outline: ["...", "..."] } or { success: false, error: "..." }
    const outlineResult = await generateOutlineFromPrompt(outlinePrompt);

    if (!outlineResult || !outlineResult.success || !Array.isArray(outlineResult.outline) || outlineResult.outline.length !== numSpreads) {
       console.error("[generateCompleteBook] Failed to generate valid outline:", outlineResult);
      throw new Error(outlineResult?.error || `Failed to generate a valid story outline with ${numSpreads} spreads.`);
    }
    const storyOutline = outlineResult.outline;
    console.log("[generateCompleteBook] Successfully generated outline:", storyOutline);

    // --- STEP 2: Generate Spread Content (Loop) ---
    const bookPagesContent = [];
    console.log(`[generateCompleteBook] Starting Step 2 loop for ${numSpreads} spreads...`);

    for (let i = 0; i < numSpreads; i++) {
      const currentSpreadNum = i + 1;
      const outlineSnippet = storyOutline[i];
      const pageNumbers = `${currentSpreadNum * 2}-${currentSpreadNum * 2 + 1}`; // e.g., 2-3, 4-5

      console.log(`[generateCompleteBook] Formatting Step 2 prompt for Spread ${currentSpreadNum}...`);
      const spreadPrompt = `
        **Goal:** Generate page text AND an inferred image prompt for a specific children's book spread.

        **Core Book Details (Reminder):**
        * Target Reading Age Range: ${storyData.ageRange || '3-8'} years old
        * Target Illustration Age Range: ${storyData.ageRange || '3-8'} years old
        * Main Character(s): ${storyData.bookCharacters.map(c => `${c.name} (${c.type}, ${c.age}, ${c.gender})`).join('; ')}
        * Art Style: ${artStyleDesc}
        * Core Theme: ${storyData.coreTheme || 'Not specified'}
        * Full Story Outline: ${JSON.stringify(storyOutline)}

        **Current Target:** Spread ${currentSpreadNum} (Pages ${pageNumbers})

        **Outline Snippet for THIS Spread:** ${outlineSnippet}

        **Instructions for AI:**
        1.  **Generate Page Text:** Write text for Spread ${currentSpreadNum} / Pages ${pageNumbers}, reflecting the **Outline Snippet**. Adhere strictly to the **Target Reading Age Range** (${storyData.ageRange || '3-8'}) for vocabulary and sentence structure (very short for board books, 1-4 simple sentences per spread for picture books). Reflect character personalities.
        2.  **Generate Inferred Image Prompt:** Based *only* on the **Page Text you just generated**, plus **Characters** and **Art Style**, create a descriptive image prompt. Specify: Subjects & Action, Setting elements, Composition/Focus, Art Style (${artStyleDesc}), Mood/Atmosphere. **DO NOT include page text in the image prompt.**

        **Output Format:** Provide the output as a JSON object with keys "text" (string) and "imagePrompt" (string). Example: {"text": "Generated text...", "imagePrompt": "Generated prompt..."}
      `;

      // Assuming generateSpreadContentFromPrompt takes the prompt and returns { success: true, content: { text: "...", imagePrompt: "..." } } or { success: false, error: "..." }
      const spreadResult = await generateSpreadContentFromPrompt(spreadPrompt);

      if (!spreadResult || !spreadResult.success || !spreadResult.content || !spreadResult.content.text || !spreadResult.content.imagePrompt) {
        console.error(`[generateCompleteBook] Failed to generate content for Spread ${currentSpreadNum}:`, spreadResult);
        // Option: Allow partial generation? Or fail the whole book? For now, let's fail.
        throw new Error(spreadResult?.error || `Failed to generate content for Spread ${currentSpreadNum}.`);
      }

      console.log(`[generateCompleteBook] Successfully generated content for Spread ${currentSpreadNum}`);
      bookPagesContent.push({
        pageNumber: currentSpreadNum, // Store spread number for reference
        text: spreadResult.content.text,
        imagePrompt: spreadResult.content.imagePrompt,
      });

      // Optional: Add a small delay between API calls if needed
      // await new Promise(resolve => setTimeout(resolve, 500));
    }

    // --- STEP 3: Assemble Book Object ---
    console.log("[generateCompleteBook] Assembling final book object...");
    const bookId = `book-${uuidv4()}`;
    const bookTitle = storyData.title || `A Story for ${mainCharacter?.name || 'You'}`; // Consider letting AI suggest title in Step 1?

    // Define structure for pages, including placeholders for images
    const finalPages = [];

    // Placeholder Cover
    finalPages.push({
      id: `page-${bookId}-cover`,
      pageNumber: 0, // Or use specific identifier
      type: 'cover',
      text: bookTitle,
      imagePrompt: `Cover image for the children's book titled '${bookTitle}' featuring ${mainCharacter?.name}. Style: ${artStyleDesc}`,
      imageUrl: null // Image generation happens later
    });

     // Placeholder Title Page
     finalPages.push({
      id: `page-${bookId}-titlepage`,
      pageNumber: 0.5, // Or use specific identifier
      type: 'title',
      text: `${bookTitle}
A Story for ${mainCharacter?.name}`,
      imagePrompt: null, // No image usually
      imageUrl: null
    });

    // Add generated content pages (adjusting numbering if needed)
    bookPagesContent.forEach((content, index) => {
       const spreadNum = index + 1;
       // Assign page numbers (e.g., Spread 1 -> Pages 2, 3; Spread 2 -> Pages 4, 5)
       // This structure assumes one text block and one image per SPREAD.
       // If you want one image per PAGE, you'll need to adjust this structure.
       finalPages.push({
         id: `page-${bookId}-${spreadNum}`,
         spreadNumber: spreadNum, // Keep track of the spread
         pageNumbers: [spreadNum * 2, spreadNum * 2 + 1], // e.g., [2, 3], [4, 5]
         type: 'content',
         text: content.text,
         imagePrompt: content.imagePrompt,
         imageUrl: null // Image generation happens later
       });
    });

     // Placeholder Back Cover
     finalPages.push({
      id: `page-${bookId}-back`,
      pageNumber: numSpreads + 1, // Or use specific identifier
      type: 'back-cover',
      text: 'The End',
      imagePrompt: null,
      imageUrl: null
    });


    const newBook = {
      id: bookId,
      title: bookTitle,
      characters: storyData.bookCharacters, // From the wizard
      pages: finalPages, // Assembled pages with prompts
      // Add other relevant metadata from storyData
      category: storyData.category,
      artStyleCode: storyData.artStyleCode, // Store the selected code
      customStyleDescription: storyData.customStyleDescription,
      ageRange: storyData.ageRange,
      storyType: storyData.storyType,
      wordCount: storyData.desiredLengthWords, // Target word count
      // Store the outline and structure choices for potential editing later?
      generationData: {
          outline: storyOutline,
          storyStart: storyData.storyStart,
          mainHurdle: storyData.mainHurdle,
          // ... store other structure choices
      }
      // status, createdAt, etc., will be added in the store action
    };

    console.log("[generateCompleteBook] Successfully created book object:", newBook);
    return { success: true, book: newBook }; // Return the structured book data

  } catch (error) {
    console.error('[generateCompleteBook] Failed:', error);
    return { success: false, error: error.message || 'An unexpected error occurred during book generation.' };
  }
};


// --- Functions below might be needed later for image generation ---

/**
 * Placeholder function to generate images for a book using the stored prompts.
 * This would likely call the Dzine API service.
 */
/*
export const generateImagesForBook = async (book) => {
  console.log(`Starting image generation for book: ${book.id}`);
  const imageGenerationService = // ... import your Dzine service ...

  const updatedPages = await Promise.all(book.pages.map(async (page) => {
    if (page.imagePrompt && !page.imageUrl) {
      console.log(`Generating image for page ${page.pageNumber || page.id} using prompt: ${page.imagePrompt}`);
      try {
        // Replace with actual call to your image generation service (e.g., Dzine)
        const imageResult = await imageGenerationService.generateImage({
           prompt: page.imagePrompt,
           style_code: book.artStyleCode,
           // ... other necessary parameters (size, quality etc.)
        });

        if (imageResult.success && imageResult.imageUrl) {
           console.log(`Successfully generated image for page ${page.pageNumber || page.id}`);
          return { ...page, imageUrl: imageResult.imageUrl };
        } else {
          console.error(`Failed to generate image for page ${page.pageNumber || page.id}:`, imageResult.error);
          return page; // Return original page data on failure
        }
      } catch (error) {
        console.error(`Error during image generation for page ${page.pageNumber || page.id}:`, error);
        return page; // Return original page data on error
      }
    }
    return page; // Return page as-is if no prompt or image already exists
  }));

  return { ...book, pages: updatedPages };
};
*/

// --- Remove Old Mock/Placeholder Functions ---
// Remove generateStoryOutline, generateSpreadContent (old versions),
// generateMockOutline, generateProperPageContent etc.


/**
 * Helper to generate a more readable name for a scene
 */
function getSceneFriendlyName(sceneId) {
  const sceneFriendlyNames = {
    // Adventure scenes
    space: 'Space Adventure',
    ocean: 'Undersea Quest',
    jungle: 'Jungle Expedition',
    mountains: 'Mountain Journey',
    safari: 'Safari Adventure',

    // Bedtime scenes
    dreams: 'Dream Journey',
    stars: 'Starry Night',
    bedroom: 'Bedtime Magic',
    night_forest: 'Moonlit Forest Tale',
    cloud_kingdom: 'Cloud Kingdom Adventure',

    // Learning scenes
    school: 'School Adventure',
    library: 'Library Quest',
    alphabet_land: 'Alphabet Land Journey',
    zoo_letters: 'Alphabet Zoo',
    garden: 'Garden of Letters',

    // Birthday scenes
    party: 'Birthday Party',
    amusement_park: 'Amusement Park Fun',
    treasure_hunt: 'Birthday Treasure Hunt',
    bakery: 'Bakery Adventure',
    parade: 'Birthday Parade',

    // Fantasy scenes
    enchanted_forest: 'Enchanted Forest',
    dragon_mountain: 'Dragon Mountain',
    fairy_kingdom: 'Fairy Kingdom',
    wizard_castle: 'Wizard Castle',
    crystal_caves: 'Crystal Caves',

    // Default
    custom_scene: 'Adventure',
  };

  return sceneFriendlyNames[sceneId] || 'Adventure';
}

/**
 * Helper to generate a category-based title
 */
function getCategoryTitle(category, sceneName) {
  switch(category) {
    case 'adventure': return sceneName || 'Amazing Adventure';
    case 'bedtime': return sceneName || 'Bedtime Story';
    case 'learning': return sceneName || 'Learning Journey';
    case 'birthday': return sceneName || 'Birthday Surprise';
    case 'fantasy': return sceneName || 'Magical Tale';
    default: return sceneName || 'Special Story';
  }
}

/**
 * Updated function to generate proper page content without placeholders
 */
function generateProperPageContent(
  outlineSnippet,
  characterName,
  spreadNumber,
  textLength,
  artStyle,
  mainScene,
  sceneDescription
) {
  // Extract page numbers from outline
  const pageMatch = outlineSnippet.match(/Pages (\d+)-?(\d+)?/);
  let pageNumbers = "";

  if (pageMatch) {
    if (pageMatch[2]) {
      pageNumbers = `${pageMatch[1]}-${pageMatch[2]}`;
    } else {
      pageNumbers = pageMatch[1];
    }
  } else {
    pageNumbers = String(spreadNumber * 2) + (spreadNumber < 16 ? `-${spreadNumber * 2 + 1}` : '');
  }

  // Generate proper text based on the outline snippet
  const text = generateProperTextFromOutline(outlineSnippet, characterName, textLength, mainScene);

  // Generate mock image prompt
  const imagePrompt = generateImagePromptFromOutline(outlineSnippet, characterName, artStyle, mainScene, sceneDescription);

  return {
    spreadNumber,
    pageNumbers,
    text,
    imagePrompt
  };
}

/**
 * Enhanced text generation function that properly processes placeholders
 */
function generateProperTextFromOutline(outlineSnippet, characterName, textLength, mainScene) {
  // Extract the core content from the outline (after the ":")
  const contentPart = outlineSnippet.split(':').slice(1).join(':').trim();

  // Get scene name for the story
  const sceneName = getSceneName(mainScene);

  // Process the content to replace placeholders with actual descriptions
  const processedContent = processPlaceholders(contentPart);

  // For demonstration purposes, create simple text
  let text = "";

  switch(textLength) {
    case 'very short':
      text = `${characterName} ${processedContent} in ${sceneName}.`;
      break;
    case 'short':
      text = `${characterName} ${processedContent} in ${sceneName}. What would happen next?`;
      break;
    case 'medium':
      text = `${characterName} ${processedContent} in ${sceneName}. It was an exciting moment. ${characterName} couldn't wait to see what would happen next.`;
      break;
    case 'longer':
      text = `${characterName} ${processedContent} in ${sceneName}. It was an exciting moment in ${characterName}'s day. The possibilities seemed endless. ${characterName} took a deep breath and continued on the adventure.`;
      break;
    default:
      text = `${characterName} ${processedContent} in ${sceneName}.`;
  }

  return text;
}

/**
 * Process any placeholder patterns in the text to convert them to proper descriptions
 */
function processPlaceholders(text) {
  // Helper function to process a specific template pattern
  const processTemplate = (text, pattern, replacementFn) => {
    const regex = new RegExp(pattern, 'g');
    return text.replace(regex, replacementFn);
  };

  // First simplify the text (basic word substitutions)
  let processed = processTemplateText(text);

  // Then handle specific placeholder/template patterns
  processed = processTemplate(processed, 'obstacle_overcome', () => 'overcame the challenge');
  processed = processTemplate(processed, 'problem_solved', () => 'solved the problem');
  processed = processTemplate(processed, 'challenge_faced', () => 'faced a big challenge');
  processed = processTemplate(processed, 'magic_discovered', () => 'discovered something magical');
  processed = processTemplate(processed, 'lesson_learned', () => 'learned an important lesson');
  processed = processTemplate(processed, 'friend_made', () => 'made a new friend');
  processed = processTemplate(processed, 'adventure_started', () => 'began an exciting adventure');
  processed = processTemplate(processed, 'resolution_found', () => 'found a perfect solution');

  return processed;
}

/**
 * Enhanced text simplification that also processes templates and placeholders
 */
function processTemplateText(text) {
  // Basic word substitutions for simplicity
  let simplified = text
    .replace(/\bacquired\b/g, "got")
    .replace(/\battempted\b/g, "tried")
    .replace(/\bdiscovered\b/g, "found")
    .replace(/\bcommenced\b/g, "started")
    .replace(/\bdifficult\b/g, "hard")
    .replace(/\bchallenging\b/g, "hard")
    .toLowerCase();

  // Also handle keyword patterns that should be converted to meaningful descriptions
  simplified = simplified
    .replace(/(_[a-z]+_)/g, (match) => {
      // Strip underscores and make more readable
      const word = match.replace(/_/g, '');
      return word.replace(/([a-z])([A-Z])/g, '$1 $2').toLowerCase();
    });

  return simplified;
}

/**
 * Generate images for a book using the character preview and style reference for consistency
 * @param {Object} book - The book object with pages and metadata
 * @param {string} mainCharacterPreviewImage - Base64 data URL of the main character's preview image
 * @param {function} [onProgress] - Optional callback called after each page image is generated, receives (updatedPages)
 * @returns {Promise<Object>} - The updated book object with imageUrl fields filled in
 */
export async function generateImagesForBookWithReferences(book, mainCharacterPreviewImage, onProgress) {
  if (!book || !book.pages || !mainCharacterPreviewImage) {
    throw new Error('Book, pages, and main character preview image are required');
  }

  // Get style code and description
  const styleCode = book.artStyleCode;
  const styleDescription = book.customStyleDescription || '';

  // Get style reference image
  let styleReferenceImage = null;
  if (styleCode) {
    try {
      styleReferenceImage = await openaiImageService.getStyleReferenceImage(styleCode);
    } catch (e) {
      styleReferenceImage = null;
    }
  }

  // Prepare references array (main character preview, style reference)
  const characterReferenceImages = [mainCharacterPreviewImage];
  if (styleReferenceImage) characterReferenceImages.push(styleReferenceImage);

  // Generate images for each page, updating as we go
  const updatedPages = [];
  for (const page of book.pages) {
    let imageUrl = null;
    try {
      if (page.type === 'cover') {
        imageUrl = await openaiImageService.generateCoverImage(
          book.title,
          book.characters.map(c => c.name),
          styleDescription,
          characterReferenceImages,
          styleCode
        );
      } else if (page.type === 'content') {
        imageUrl = await openaiImageService.generateSceneImage(
          page.imagePrompt,
          book.characters.map(c => c.name),
          styleDescription,
          styleReferenceImage,
          page.pageNumber,
          {
            // For now, only main character reference; extend for multi-character later
            [book.characters[0]?.id || 'main']: {
              name: book.characters[0]?.name,
              referenceImageUrl: mainCharacterPreviewImage,
              isFirstAppearance: false
            }
          }
        );
      }
      // Optionally upload the image and get a persistent URL
      if (imageUrl && imageUrl.startsWith('data:image')) {
        imageUrl = await uploadImageAndGetUrl(imageUrl);
      }
    } catch (e) {
      imageUrl = null;
    }
    updatedPages.push({ ...page, imageUrl });
    if (typeof onProgress === 'function') {
      onProgress([...updatedPages]);
    }
  }
  return { ...book, pages: updatedPages };
}